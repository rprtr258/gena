package gena

/*
XX YX  0
XY YY  0
X0 Y0  1
*/
type Matrix struct {
	XX, YX,
	XY, YY,
	X0, Y0 float64
}

var Identity = Matrix{
	1, 0,
	0, 1,
	0, 0,
}

func Translate(v V2) Matrix {
	return Matrix{
		1, 0,
		0, 1,
		v.X(), v.Y(),
	}
}

func Scale(v V2) Matrix {
	return Matrix{
		v.X(), 0,
		0, v.Y(),
		0, 0,
	}
}

func Rotate(angle float64) Matrix {
	c := Cos(angle)
	s := Sin(angle)
	return Matrix{
		c, s,
		-s, c,
		0, 0,
	}
}

func Shear(v V2) Matrix {
	return Matrix{
		1, v.Y(),
		v.X(), 1,
		0, 0,
	}
}

func (a Matrix) Multiply(b Matrix) Matrix {
	return Matrix{
		a.XX*b.XX + a.YX*b.XY,
		a.XX*b.YX + a.YX*b.YY,
		a.XY*b.XX + a.YY*b.XY,
		a.XY*b.YX + a.YY*b.YY,
		a.X0*b.XX + a.Y0*b.XY + b.X0,
		a.X0*b.YX + a.Y0*b.YY + b.Y0,
	}
}

func (a Matrix) TransformVector(p V2) V2 {
	return P(
		a.XX*p.X()+a.XY*p.Y(),
		a.YX*p.X()+a.YY*p.Y(),
	)
}

func (a Matrix) TransformPoint(v V2) V2 {
	return P(
		a.XX*v.X()+a.XY*v.Y()+a.X0,
		a.YX*v.X()+a.YY*v.Y()+a.Y0,
	)
}

func (a Matrix) Translate(v V2) Matrix {
	return Translate(v).Multiply(a)
}

func (a Matrix) Scale(v V2) Matrix {
	return Scale(v).Multiply(a)
}

func (a Matrix) Rotate(angle float64) Matrix {
	return Rotate(angle).Multiply(a)
}

func (a Matrix) Shear(v V2) Matrix {
	return Shear(v).Multiply(a)
}

// TODO: not tested at all, generated by AI, so 99% it is bredik
func (a Matrix) Inverse() Matrix {
	return Matrix{
		a.YY / (a.XX*a.YY - a.XY*a.YX),
		-a.YX / (a.XX*a.YY - a.XY*a.YX),
		-a.XY / (a.XX*a.YY - a.XY*a.YX),
		a.XX / (a.XX*a.YY - a.XY*a.YX),
		(a.XY*a.YY - a.YX*a.XY) / (a.XX*a.YY - a.XY*a.YX),
		(a.X0*a.YY - a.Y0*a.XY) / (a.XX*a.YY - a.XY*a.YX),
	}
}
